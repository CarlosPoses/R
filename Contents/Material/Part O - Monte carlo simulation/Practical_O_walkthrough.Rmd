---
title: "Practical_O"
author: "Gerko Vink"
date: "Statistical Programming in R"
output: html_document
---
  
  ```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

We use the following packages:
```{r message=FALSE, warning=FALSE}
library(plyr)
library(dplyr)
library(magrittr)
library(ggplot2)
```

---

#### Exercise

1. **Sample 100 samples from a standard normal distribution. **
2. **For each of these samples, calculate the following statistics for the mean:**

 - absolute bias
 - standard error
 - lower bound of the 95% confidence interval
 - upper bound of the 95% confidence interval
 
3. **Create a plot that demonstrates the following**

    ***"A replication of the procedure that generates a 95% confidence interval 
    that is centered around the sample mean would cover the population value at 
    least 95 out of 100 times"*** [(Neyman, 1934)](https://www.google.nl/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0ahUKEwjk4LaD6LrXAhUGC8AKHdATBhMQFggoMAA&url=http%3A%2F%2Fwww.stat.cmu.edu%2F~brian%2F905-2008%2Fpapers%2Fneyman-1934-jrss.pdf&usg=AOvVaw3KRw9DSklPihrYIM0_zRrC)
    
4. **Present a table containing all simulated samples for which the resulting confidence interval does 
not contain the population value.**

---

#### SOLUTION:

We start by fixing the random seed. Otherwise this whole exercise is redundant.
```{r}
set.seed(1234)
```

Then, we draw 100 samples from a standard normal distribution, i.e. a distribution with $\mu=0$ and $\sigma^2=1$, such that for any drawn sample $X$ we could write $X \sim \mathcal{N}(0, 1)$. No specification about the size of the samples is explicitly requested, so for computational reasons a mere 5000 cases would suffice to obtain a detailed approximation.
```{r}
require(plyr)
samples <- rlply(100, rnorm(5000, mean = 0, sd = 1))
```
We use the `plyr::rlply()` function to draw the 100 samples and return the resulting output as a list. Further, we extract the following sources of information for each sample:

- the sample mean $\bar{x}$.
- the absolute bias: i.e. $|\bar{x} - \mu|$, which would be $\bar{x}$ in this case. 
- the standard error of the mean: $SE = \sigma/\sqrt{n}$, where $\sigma$ is the known population standard deviation and $n$ is the number of observations in the sample. 
- the upper- and lower bounds of the 95% confidence interval about the sample mean:

```{r}
info <- function(x){ 
  M <- mean(x)
  DF <- length(x) - 1
  SE <- 1 / sqrt(length(x))
  INT <- qt(.975, DF) * SE
  return(c(M, M - 0, SE, M - INT, M + INT))
}
format <- c("Mean" = 0, "Bias" = 0, "Std.Err" = 0, "Lower" = 0, "Upper" = 0)
```

We can then proceed by creating a piped process. The following code is written with the pipe functionality from package [`magrittr`](http://magrittr.tidyverse.org) - FYI: [`dplyr`](http://dplyr.tidyverse.org) adopted `magrittr`, so `dplyr` would also work here. 
```{r warning=FALSE, message=FALSE}
require("magrittr")
results <- samples %>%
  vapply(., info, format) %>%
  t()
```

Because object `samples` is a list, we can execute funtion `vapply()` to obtain a numerical object with the results of function `info()`. `vapply()` allows you to return output to a pre-defined format. Function $t()$ is here used to obtain the transpose of `vapply()`'s return - the resulting object has all information in the columns. 

To create an indicator for the inclusion of the population value $\mu=0$ in the confidence interval, we can add the following coverage column `cov` to the data:
```{r}
results <- results %>%
  as.data.frame() %>%
  mutate(Covered = Lower < 0 & 0 < Upper)
```
Converting the numerical object to an object of class `data.frame` allows for a more convenient calling of elements. Now we can simply take the column means over dataframe `results` to obtain the average of the estimates returned by `info()`.
```{r}
colMeans(results)
```

We can see that 95 out of the 100 samples cover the population value. 

To identify the samples for which the population value is not covered, we can use column `cov` as it is already a logical evaluation. 
```{r}
table <- results[!results$Covered, ]
```

To present this info as a nicer table, package `kableExtra` is a wonderful extension to use with `rmarkdown` (remember that I generate these documents with `rmarkdown` from within `RStudio`:
```{r, warning=FALSE, message=FALSE}
require(knitr)
require(kableExtra)
kable(table)
```

or even nicer:
```{r}
kable(table, "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = F)
```

To create a graph that would serve the purpose of the exercise, one could think about the following graph:

```{r warning=FALSE, message=FALSE}
require(ggplot2)
limits <- aes(ymax = results$Upper, ymin = results$Lower)

ggplot(results, aes(y=Mean, x=1:100, colour = Covered)) + 
  geom_hline(aes(yintercept = 0), color = "dark grey", size = 2) + 
  geom_pointrange(limits) + 
  xlab("Simulations 1-100") +
  ylab("Means and 95% Confidence Intervals")
```

To just plot the 5 cases that do not overlap with the population parameter:
```{r}
require(ggplot2)
limits <- aes(ymax = table$Upper, ymin = table$Lower)

ggplot(table, aes(y=Mean, x=1:5)) + 
  geom_hline(aes(yintercept = 0), color = "dark grey", size = 2) + 
  geom_pointrange(limits, col = "red") + 
  xlab("Simulations 1-100") +
  ylab("Means and 95% Confidence Intervals")
```

---

End of Practical

